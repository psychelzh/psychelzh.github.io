{
  "hash": "2a19b6e98c6748327b2d9b4266763e72",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Benchmark Matrix Operations\ndate: 2024-01-09\ndate-modified: last-modified\ncategories:\n  - benchmark\n  - coding\nexecute:\n  warning: false\n---\n\n\nRecently, I am trying to speed up my connectome predictive modeling code. I found that the matrix operations are the bottleneck. Specifically, I need a faster version of `scale()`. Based on [this blog](A Faster Scale Function | A HopStat and Jump Away (wordpress.com), I decided to benchmark the matrix operations in different packages from [fastverse](https://fastverse.github.io/fastverse/).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(collapse)\nrequireNamespace(\"bench\")\n```\n:::\n\n\n# Row Means\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwithr::local_seed(1)\nbench <- bench::press(\n  nrow = c(10, 100, 1000),\n  ncol = c(100, 1000, 10000),\n  {\n    data <- matrix(rnorm(nrow * ncol), nrow = nrow)\n    bench::mark(\n      collapse = collapse::fmean(data),\n      Rfast = Rfast::colmeans(data),\n      matrixStats = matrixStats::colMeans2(data),\n      base = .colMeans(data, nrow, ncol)\n    )\n  }\n)\n```\n:::\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\nplot(bench)\n```\n\n::: {.cell-output-display}\n![Benchmark of row means](index_files/figure-html/fig-rowmeans-1.png){#fig-rowmeans width=768}\n:::\n:::\n\n\n# Row SDs\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwithr::local_seed(1)\nbench <- bench::press(\n  nrow = c(10, 100, 1000),\n  ncol = c(100, 1000, 10000),\n  {\n    data <- matrix(rnorm(nrow * ncol), nrow = nrow)\n    bench::mark(\n      collapse = collapse::fsd(data),\n      Rfast = Rfast::colVars(data, std = TRUE),\n      matrixStats = matrixStats::colSds(data)\n    )\n  }\n)\n```\n:::\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\nplot(bench)\n```\n\n::: {.cell-output-display}\n![Benchmark of row SDs](index_files/figure-html/fig-rowsds-1.png){#fig-rowsds width=768}\n:::\n:::\n\n\n# Row-wise Operations\n\nUnfortunately, based on [this issue](https://github.com/HenrikBengtsson/matrixStats/issues/238), rowwise computations are not easy to be speeded in matrixStats. So further benchmarking will drop it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwithr::local_seed(1)\nbench <- bench::press(\n  nrow = c(10, 100, 1000),\n  ncol = c(100, 1000, 10000),\n  {\n    data <- matrix(rnorm(nrow * ncol), nrow = nrow)\n    vec <- rnorm(ncol)\n    bench::mark(\n      collapse = data %r-% vec,\n      Rfast = Rfast::eachrow(data, vec, \"-\"),\n      base = data - rep(vec, each = nrow)\n    )\n  }\n)\n```\n:::\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\nplot(bench)\n```\n\n::: {.cell-output-display}\n![Benchmark of row-wise operations](index_files/figure-html/fig-rowwise-1.png){#fig-rowwise width=768}\n:::\n:::\n\n\n# Scale\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfscale_rfast <- function(x) {\n  means <- Rfast::colmeans(x)\n  sds <- Rfast::colVars(x, std = TRUE)\n  Rfast::eachrow(\n    Rfast::eachrow(x, means, \"-\"),\n    sds, \"/\"\n  )\n}\nwithr::local_seed(1)\nbench <- bench::press(\n  nrow = c(10, 100, 1000),\n  ncol = c(100, 1000, 10000),\n  {\n    data <- matrix(rnorm(nrow * ncol), nrow = nrow)\n    bench::mark(\n      collapse = fscale(data),\n      Rfast = fscale_rfast(data),\n      base = scale(data),\n      check = FALSE # base scale will add attributes\n    )\n  }\n)\n```\n:::\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\nplot(bench)\n```\n\n::: {.cell-output-display}\n![Benchmark of scale](index_files/figure-html/fig-scale-1.png){#fig-scale width=768}\n:::\n:::\n\n\n# Conclusion\n\nFrom the above figures, we will find Rfast is the fastest package for matrix operations. Previously, I have used collapse package, which is actually fast enough. But now I will switch to Rfast.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}